---
description: Changeset generation guidelines and best practices
alwaysApply: true
requireFile: ./contributing/changeset.md
---

# Changeset Generation Rules

## Always Output to Correct Directory

When generating changesets, **always** create them in the `.changeset` directory (not `.changesets`). Changesets must follow the exact path structure:
```
.changesets/[filename].md
```

## Changeset Format Requirements

### Frontmatter Structure
Each changeset must include proper YAML frontmatter:
```md
---
"@equinor/fusion-package-name": patch
---

Description of changes...
```

### Version Types
Use semantic versioning appropriately:
- `patch`: Backward compatible bug fixes
- `minor`: Backward compatible new features
- `major`: Breaking changes

## Context for Changeset Generation

When generating changesets, determine what changes to include based on the current git state:

### Git State Priority (in order):
1. **Staged changes** - If there are staged changes, analyze only the staged content
2. **Unstaged changes** - If no staged changes but unstaged changes exist, analyze unstaged content
3. **No changes** - If no local changes, analyze the entire branch

### Comparison Target:
- **With remote branch**: Compare against `origin/${BRANCH}` (if branch has remote tracking)
- **Without remote branch**: Compare against `origin/main`
- **Fallback**: Compare against `origin/main` if remote branch not found

### How to Determine Context:
```bash
# Check for staged changes
git diff --cached --name-only

# Check for unstaged changes  
git diff --name-only

# Check current branch and remote
git branch -vv
```

## Feature/Fix Branch Changeset Rules

When working on content within a feature/fix branch:

### Check Existing Changesets First
**BEFORE creating any changeset, check for existing changesets in the `.changeset/` directory.** Look for changesets that might already cover your changes to avoid duplicates.

### No Changesets for Internal Refactors
**DO NOT create changesets for internal refactors that don't affect consumers** since they're not in main yet. Only create changesets for changes that actually require version bumps or affect package consumers.

### What NOT to Create Changesets For (Internal Changes):
- Internal refactoring without API changes
- Code comments and documentation improvements  
- Process management improvements
- Error message enhancements
- Internal helper function changes
- Code cleanup that doesn't change public APIs
- Debug logging improvements
- Type definition improvements (internal only)

### What SHOULD Create Changesets (Consumer-Affecting Changes):
- New public API methods or exports
- Breaking changes to existing APIs
- Bug fixes that affect consumer behavior
- New features that consumers will use
- Changes to public interfaces or types
- Configuration changes that affect consumers

### Decision Tree for AI:
1. **Are you on a feature/fix branch?** → Check existing changesets first
2. **Does the change affect public APIs or consumers?** → Create changeset
3. **Is it only internal refactoring/improvements?** → Skip changeset
4. **Are you unsure?** → Ask: "Would a consumer notice this change?" If no → Skip changeset

## Best Practices

### Single Package Per Changeset
**Prefer a single package per changeset:** Each changeset should ideally affect only one package. If multiple packages affected, write one for each. This keeps versioning and changelogs clear and makes releases easier to manage.

### Clear and Descriptive Summaries
- Write clear, concise, and descriptive summaries
- Explain the impact of the change
- Use present tense (e.g., "Add feature" not "Added feature")

### Detailed Explanations
For each package changed, provide:
1. **What changed** - Brief description
2. **Why it changed** - Rationale and benefits
3. **How to migrate** (if applicable) - Consumer-facing changes
4. **Code examples** (optional) - Usage examples for new features

### File Naming
- prefix with package name (exclude scope, example '@equinor')
- generate a short name based on change.
- Examples: `cli_added-feature-x.md`, `module-http_fixed-http-headers.md`

## Quality Assurance

Before finalizing:
- [ ] Changeset correctly reflects the changes made
- [ ] Version bump type is appropriate (patch/minor/major)
- [ ] Description is clear and actionable
- [ ] All affected packages are included
- [ ] Follows the format from [contributing/changeset.md](mdc:contributing/changeset.md)

## Example Format

```md
---
"@equinor/fusion-framework-cli": patch
---

Enhanced Vite configuration with improved TypeScript path resolution.

- Removed deprecated `vite-plugin-tsconfig-paths` dependency
- Updated `load-vite-config.ts` to remove plugin usage
- Improved build performance and reduced bundle size
```

## Common Mistakes to Avoid

- ❌ Creating changesets in wrong directory (should be `.changeset/`, not `.changesets/`)
- ❌ Creating changesets for internal refactors that don't affect consumers
- ❌ Not checking existing changesets before creating new ones on feature branches
- ❌ Grouping unrelated changes in single changeset
- ❌ Using vague or unclear descriptions
- ❌ Forgetting to include all affected packages
- ❌ Incorrect version bump types
- ❌ Using package-specific file names that cause merge conflicts
- ❌ Analyzing wrong git state (unstaged when staged changes exist)

## Creation Methods

manually add file to `./changeset` 